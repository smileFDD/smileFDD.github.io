<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用webpack4手动构建react项目]]></title>
    <url>%2F2018%2F02%2F26%2FstartReact%2F</url>
    <content type="text"><![CDATA[webpack Webpack 是一个前端资源加载/打包工具。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。自从 gulp，Grunt 等一些前端工具兴起后，才真正把前端工程化引入，不仅简化了开发流程，更引入了一些前沿思想。 webpack 工作方式 把你的项目当做一个整体，通过一个给定的主文件（entry）（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。 webpack 4 实际上在webpack 4之前，webpack有着很多黑点，也催生了后期rollup和parcel。而webpack主要问题存在于： 配置过于复杂。 文档缺失，尤其中文文档。 编译、打包速度过慢。等 原来对于前端来说，打开编辑器就可以撸代码的日子一去不复返，大概配置前端开发环境就需要一天吧 :smile: 。对于 webpack4 来说，这一个大版本升级做了诸多优化，主要包含如下： 环境: 不再支持 node.js 4, 源代码已升级到更高的ecmascript版本。 用法: 您现在必须在production or development两种模式之间选择（mode or --mode) production默认提供所有可能的优化，如代码压缩/作用域提升等 development模式下允许注释和 eval 下的 source maps。 production模式下不支持 watch，development模式下针对代码变化后的重新打包进行了优化。 production模式下默认提供模块合并（作用域提升）。 你可以配置 optimization 自定义模式。 process.env.NODE_ENV 的值不需要再定义，默认对应当前模式。 并且可以设置 none 模式可以禁用所有的功能。 语法 在 webpack 4 中，import() 会返回一个带命名空间(namespace)的对象，这对 ES Module 不会有影响，但对于遵循 commonjs 规范的模块则会加一层包裹。 在webpack 4 中如果你使用 import（） 导入 CommonJs 模块可能会破坏你的代码。 配置 删除了一些常用内置插件： NoEmitOnErrorsPlugin -&gt; optimization.noEmitOnErrors (生产模式默认) ModuleConcatenationPlugin -&gt; optimization.concatenateModules （生产模式默认） NamedModulesPlugin -&gt; optimization.namedModules （开发模式默认）。 删除了 CommonsChunkPlugin，取而代之的是 optimization.splitChunks 和 optimization.runtimeChunk，这提供了细粒度的缓存策略控制 JSON处理 webpack现在默认处理JSON。 将JSON通过加载器转换为JS时，可能需要添加类型：javascript / auto. 还支持对 JSON 的 Tree Shaking。当使用 ESM 语法 import json 时，webpack 会处理掉JSON Module 中未使用的导出。 优化 uglifyjs-webpack-plugin 发布 v1，支持 ES2015 使用 JSONP 数组来代替 JSONP 函数 –&gt; 异步支持 重大功能性更新 Modules(模块)： webpack 现在支持以下文件类型： javascript/auto: (webpack 3中的默认类型)支持所有的JS模块系统：CommonJS、AMD、ESM javascript/esm: EcmaScript 模块，在其他的模块系统中不可用。 javascript/dynamic: 仅支持 CommonJS &amp; AMD，ES moudle 不可用。 json: 可通过 require 和 import 导入的 JSON 格式的数据(默认为 .json 的文件) webassembly/experimental: WebAssembly 模块(试验阶段，默认为 .wasm 的文件)。 与javascript/auto相比，javascript/esm更严格地处理ESM文档 导入的名称需要在导入的模块上存在。 动态模块（非esm，即CommonJs）只能通过default导入，其他方式（包括命名空间导入）都会发出错误。 以后缀名为.mjs的模块默认为 javascript/esm。 WebAssembly模块 可以导入其他模块（JS和WASM）。 从WebAssembly模块导出的模块将通过ESM导入进行验证。 只能用于异步模块。 WebAssembly为实验性功能。 Optimization(优化): sideEffects: package.json现在支持配置false。 package.json中的sideEffects还支持glob表达式和glob表达式的数组。 使用 JSONP 数组替代 JSONP 函数，异步脚本支持，不再依赖于加载顺序。 引入了新的optimization.splitChunks选项 detail。 无用代码现在由webpack自动处理。 Before: 在 Uglify 中处理无用代码。 现在： webpack 默认处理。 这可以防止无用代码中存在import()时出现错误。 Syntax(语法): 通过import()可以支持webpackInclude和webpackExclude。它们允许在使用动态表达式过滤文件。 减少使用System.import()现在使用System.import()`会发出警告。 你可以配置 Rule.parser.system: true 禁用警告。 配置 Rule.parser.system: false可以禁用 System.import。 Configuration(配置)： 现在可以使用module.rules[].resolve来配置解析。它将合并到全局配置中。 在production 模式，optimization.minimize 默认打开； development 模式默认关闭。 Usage(用法)： 部分插件配置现在将被验证。 CLI已转移到webpack-cli，您需要安装webpack-cli才能使用CLI。 [] Performance(性能提升)： UglifyJs 现在默认进行缓存。 多重性能改进，特别是对于频繁修改的文件的重新编译。 对于RemoveParentModulesPlugin的性能改进。 Stats(统计)： 统计信息可以显示嵌套中的模块。 其他更多信息可以查看 releases。 从 angular1.x 到 vue 再到 react 的心路历程 网上有太多的文章去讨论目前前端三大框架的优缺点，其实有些时候可以说适合你的才是最好的，没必要过多的纠结好或不好的问题。从开始的 jquery 的原生态开发到 angularjs的双向绑定再到部门技术选型从而切到 vuejs （从1到2）再到现在对 react的尝试，可谓是三大框架走了个遍。有些时候不得不感叹 我圈真乱 斜眼笑。 准备工作 因为目前项目使用的 vue 框架，并且对 vue 相关项目配置有所了解，所以项目架构直接采用webpack + es2015 + react 构建，并且采用手撸 webpack 配置加深印象。 创建项目 mkdir react-map // 创建 react-map 文件夹 cd react-map // 进入文件夹 使用 npm init 初始化项目，按需要进行配置。 安装依赖 npm install webpack-cli webpack webpack-bundle-analyzer webpack-dev-server webpack-merge uglifyjs-webpack-plugin html-webpack-plugin extract-text-webpack-plugin optimize-css-assets-webpack-plugin friendly-errors-webpack-plugin --save-dev // 安装 webpack （目前已升级到 4） npm install react react-dom --save // 参考：https://facebook.github.io/react/docs/installation.html 包名 简介 作用 版本 webpack 模块打包器 对 react 项目的打包，ES2015+ 的代码转换，静态资源处理等 ^4.0.1 react js 框架 react 基础框架 ^16.2.0 react-dom 操作 DOM 搭配 react 用了操作dom的 ^16.2.0 因为需要采用 es2015 语法 所以还应当安装babel-loader以及其他相关依赖, 具体也可以参考 vue 项目配置。 npm install babel-loader babel-core babel-preset-es2015 babel-preset-react babel-eslint --save-dev 样式预处理器保持和现有项目保持一致，任然采用 scss, 但是任然需要处理内联样式和 css 文件。 npm install css-loader style-loader node-sass sass-loader --save-dev 安装 eslint 相关 npm install eslint eslint-config-airbnb eslint-plugin-babel eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react eslint-friendly-formatter --save-dev 安装静态文件 loader 相关 npm install url-loader file-loader portfinder --save-dev npm install postcss-url postcss-loader postcss-import autoprefixer --save-dev webpack 配置 编写对应的webpack 配置]]></content>
      <categories>
        <category>front-end</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deepin下前端开发环境搭建]]></title>
    <url>%2F2017%2F12%2F11%2Fdeepin%2F</url>
    <content type="text"><![CDATA[简介：deepin下前端相关开发环境搭建，包括nodejs安装，webstorm安装，jdk安装,git安装等。 nodejs安装教程 下载源码：https://nodejs.org/en/download/，优先选择长期支持版，选择Source Code下载 1wget https://nodejs.org/dist/v8.9.3/node-v8.9.3.tar.gz 解压并安装 123456789101112131415161718// 解压源码压缩包sudo tar xvf node-v8.9.3.tar.gz// 切换到解压后的文件夹内cd node-v8.9.3// 开始安装，编译大概会有20分钟之久sudo ./configure sudo make sudo make install // 查看当前安装的Node的版本 node -v v8.9.3// 查看NPM版本npm -v5.5.1 git安装教程123456789101112131415161718192021222324252627282930Debian/UbuntuFor the latest stable version for your release of Debian/Ubuntu# apt-get install gitFor Ubuntu, this PPA provides the latest stable upstream Git version# add-apt-repository ppa:git-core/ppa # apt update; apt install gitFedora# yum install git (up to Fedora 21)# dnf install git (Fedora 22 and later)Gentoo# emerge --ask --verbose dev-vcs/gitArch Linux# pacman -S gitopenSUSE# zypper install gitMageia# urpmi gitNix/NixOS# nix-env -i gitFreeBSD# pkg install gitSolaris 9/10/11 (OpenCSW)# pkgutil -i gitSolaris 11 Express# pkg install developer/versioning/gitOpenBSD# pkg_add gitAlpine$ apk add git JDK环境配置1234567891011121314151617下载安装Oracle JDK下载JDK的tar.gz包解压压缩包进入下载目录cd ~/Download解压tar.gz包tar -zxvf jdk-8u152-linux-x64.tar.gz安装JDKsudo mv jdk1.8.0_152/ /usr/lib/jvm/jdk1.8.0_152JDK环境变量配置修改配置文件sudo vim /etc/profile 在文件的末尾增加内容 123JAVA_HOME=/usr/lib/jvm/jdk1.8.0_152export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 注意jdk的路径和版本 使配置生效 1source /etc/profile 配置默认JDK创建新的java版本在shell用update-alternatives命令创建新的系统命令链接： 12345sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/jdk1.8.0_152/bin/javac 1171sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/jdk1.8.0_152/bin/java 1171sudo update-alternatives --install /usr/bin/jar jar /usr/lib/jvm/jdk1.8.0_152/bin/jar 1171 sudo update-alternatives --install /usr/bin/javah javah /usr/lib/jvm/jdk1.8.0_152/bin/javah 1171 sudo update-alternatives --install /usr/bin/javap javap /usr/lib/jvm/jdk1.8.0_152/bin/javap 1171 update-alternatives是ubuntu系统中专门维护系统命令链接符的工具，后面的1171是用来指定当前链接的优先级，最高的优先级将自动被设置为默认版本。 可以用下面的命令查看JAVA的版本和优先级： 1update-alternatives --display java 选择JAVA的版本执行命令 1update-alternatives --config java 输出 有 2 个候选项可用于替换 java (提供 /usr/bin/java)。 选择 路径 优先级 状态123* 0 /usr/lib/jvm/jdk1.8.0_152/bin/java 1171 自动模式 1 /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java 1081 手动模式 2 /usr/lib/jvm/jdk1.8.0_152/bin/java 1171 手动模式 要维持当前值[*]请按&lt;回车键&gt;，或者键入选择的编号： 上图可以看到刚刚配置的JDK 1.8优先级配置为1171，高于原有的1081，所以被自动设置为默认。 测试查看JAVA版本在shell上执行下面命令 1java -version 如果得到如下输出，证明JDK已经成功安装配置了。 1234Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=gaspjava version "1.8.0_152"Java(TM) SE Runtime Environment (build 1.8.0_152-b16)Java HotSpot(TM) 64-Bit Server VM (build 25.152-b16, mixed mode) webstorm安装 官网：http://www.jetbrains.com/webstorm/ 安装过程： 12345678910111213解压tar zxvf WebStorm-2017.3.tar.gz移动sudo mv WebStorm-173.3727.108/ /opt/WebStorm/创建链接sudo ln -s /opt/WebStorm/ /opt/WebStorm启动/opt/WebStorm/bin/webstorm.sh添加Dash图标 激活 http://www.imsxm.com/jetbrains-license-server.html]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>nodejs</tag>
        <tag>soft</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POSTGIS安装使用]]></title>
    <url>%2F2017%2F05%2F18%2Fpostgis%2F</url>
    <content type="text"><![CDATA[写在前面PostgreSQL 是一种对象-关系型数据库管理系统（ORDBMS），也是目前功能最强大、特性最丰富和最复杂的自由软件数据库系统。它起源于伯克利（BSD）的数据库目前功能最强大、特性最丰富和最复杂的研究计划，目前是最重要的开源数据库产品开发项目之一， 有着非常广泛的用户。 安装]]></content>
      <categories>
        <category>GIS</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>GIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态抓取bing搜索每日一图]]></title>
    <url>%2F2017%2F04%2F09%2FgetBingPic%2F</url>
    <content type="text"><![CDATA[写在前面大家都知道微软的Bing搜索引擎首页每天都会提供了一些有趣的图片，而这些图片很多都是有故事含义的，很多网友每天去访问bing首页都是为了这些图片而去的。而最近在搭建个人博客时的背景图片非常想使用一些漂亮的图片。当然我们可以使用图床和放置高清大图，但是考虑到不方便，所以想到使用bing的每日一图。 思路我们打开开发者工具，可以看到有个请求是获取图片地址的：123456789101112131415161718192021222324252627282930313233var url = 'http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1&amp;nc=1491746841662&amp;pid=hp';// 结果 url即为图片地址var res = &#123; "images":[ &#123; "startdate":"20170408", "fullstartdate":"201704081600", "enddate":"20170409", "url":"/az/hprichbg/rb/TulipFestival_ZH-CN8467334837_1920x1080.jpg", "urlbase":"/az/hprichbg/rb/TulipFestival_ZH-CN8467334837", "copyright":"弗农山上绽放的郁金香，华盛顿 (© Pete Saloutos/plainpicture)", "copyrightlink":"/search?q=%e9%83%81%e9%87%91%e9%a6%99&amp;form=hpcapt&amp;mkt=zh-cn", "quiz":"/search?q=Bing+homepage+quiz&amp;filters=WQOskey:%22HPQuiz_20170408_TulipFestival%22&amp;FORM=HPQUIZ", "wp":true, "hsh":"2587e7cb9ba2b13b50dd321ca94f56b1", "drk":1, "top":1, "bot":1, "hs":[ ] &#125; ], "tooltips":&#123; "loading":"Loading...", "previous":"Previous image", "next":"Next image", "walle":"This image is not available to download as wallpaper.", "walls":"Download this image. Use of this image is restricted to wallpaper only." &#125; &#125; 正常我们请求的话直接请求图片就可以了 1var url = 'http://cn.bing.com/az/hprichbg/rb/TulipFestival_ZH-CN8467334837_1920x1080.jpg' 但是不出所料的出现了跨域问题，所以就考虑到使用代理转发的方式来进行请求。 解决方案客户端发起请求到nodejs服务器，nodejs收到后请求第三方服务器取得数据，返回给客户端。 1client ajax --&gt; nodejs recived --&gt; nodejs send request --&gt; respone to client 范例不使用外部package的代码123456789101112131415161718192021222324252627282930313233/** * Created by FDD on 2017/4/9. */var http = require('http');var zlib = require('zlib');// 创建http服务var app = http.createServer(function (req, res) &#123; // 查询本机ip // var base = '/HPImageArchive.aspx?format=js&amp;idx=&#123;idx&#125;&amp;n=1&amp;nc=&#123;nc&#125;&amp;pid=hp&amp;video=1'; // var idx = parseInt(Math.random() * 10); // var nc = (new Date()).getTime(); // var url = base.replace('&#123;idx&#125;', idx.toString()).replace('&#123;nc&#125;', nc.toString()); var sreq = http.request(&#123; host: 'cn.bing.com', // 目标主机 path: req.url, // 目标路径 gzip: true, method: req.method // 请求方式 &#125;, function (sres) &#123; // console.log(req.url) sres.pipe(res); sres.on('end', function () &#123; console.log('done'); &#125;); &#125;); if (/POST|PUT/i.test(req.method)) &#123; req.pipe(sreq); &#125; else &#123; sreq.end(); &#125;&#125;);// 访问127.0.0.1:3001查看效果app.listen(3001);console.log('server started on 127.0.0.1:3001'); 使用superAgent的代码注意这一段代码是为了解决返回乱码和跨域问题 1234res.writeHead(200, &#123; "Content-Type": "text/html;charset=utf-8", "Access-Control-Allow-Origin": "*" &#125;); 123456789101112131415161718192021222324252627var http = require('http');// 创建http服务var app = http.createServer(function (req, res) &#123; res.writeHead(200, &#123; "Content-Type": "text/html;charset=utf-8", "Access-Control-Allow-Origin": "*" &#125;); // 使用了superagent来发起请求 var charset = require('superagent-charset'); var superagent = require('superagent'); charset(superagent); // 查询本机ip，这里需要根据实际情况选择get还是post var base = 'http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=&#123;idx&#125;&amp;n=1&amp;nc=&#123;nc&#125;&amp;pid=hp&amp;video=1'; var idx = parseInt(Math.random() * 10); var nc = (new Date()).getTime(); var url = base.replace('&#123;idx&#125;', idx.toString()).replace('&#123;nc&#125;', nc.toString()); var sreq = superagent.get(url); sreq.charset('utf-8'); // JSON.stringify(res); sreq.pipe(res); sreq.on('end', function()&#123; console.log('done'); &#125;);&#125;);// 访问127.0.0.1:3002查看效果app.listen(3002);console.log('server started on 127.0.0.1:3002'); 使用Express + superAgent的代码123456789101112131415161718192021/** * Created by FDD on 2017/4/9. */var express = require('express');var app = express();app.get('/', function (req, res) &#123; // 使用了superagent来发起请求 var superagent = require('superagent'); // 查询本机ip，这里需要根据实际情况选择get还是post var base = 'http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=&#123;idx&#125;&amp;n=1&amp;nc=&#123;nc&#125;&amp;pid=hp&amp;video=1'; var idx = parseInt(Math.random() * 10); var nc = (new Date()).getTime(); var url = base.replace('&#123;idx&#125;', idx.toString()).replace('&#123;nc&#125;', nc.toString()); var sreq = superagent.get(url); sreq.pipe(res); sreq.on('end', function()&#123; console.log('done'); &#125;);&#125;);app.listen(3001);console.log('Express started on 127.0.0.1:3001');]]></content>
      <categories>
        <category>前端</category>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用travis持续集成工具自动部署博客]]></title>
    <url>%2F2017%2F04%2F08%2Ftravis%2F</url>
    <content type="text"><![CDATA[简介 完善一下早期文章。虽然网上已有很多关于博客自动部署的教程，但是真正实践起来并不是一番丰顺。所以将踩过的坑记录下来也是必要的。 自动部署方案选择Webhook Webhook，也就是人们常说的钩子，是一个很有用的工具。你可以通过定制 Webhook 来监测你在 Github上的各种事件，包括提交合并分支等事件。并且github和gitlab对webhook的支持比较好。 主要思路就是当有新的 push 操作后，触发webhook的回调，进行仓库拉取更新和编译，并且将编译后的文件推送到 git 仓库或者特定服务器上，就完成了自动部署。 但是此方案需要有一个服务器，所以暂时不考虑。 Travis CI Travis CI 是目前新兴的开源持续集成构建项目。目前我的大多数的github项目都已经移入到Travis CI的构建队列中。 travis配置 开启travis中要构建的项目，并指定触发条件。 配置环境变量Environment Variables，主要目的是将HEXO_ALGOLIA_INDEXING_KEY(algolia的key)和TRAVIS_GITHUB（Github的Access Token）以私有方式配置到构建环境中。 配置 .travis.yml 配置文件, 安装node，配置主题，hexo编译，自动配置algolia搜索字段的更新，将构建结果 push到 github 对应仓库。 12345678910111213141516171819202122language: node_jsnode_js: nodecache: directories: - node_modulesbefore_install:- npm install -g hexo-cliinstall: npm installscript:- git clone https://github.com/sakitam-fdd/hexo-theme-next.git themes/next- hexo clean- hexo generate- export HEXO_ALGOLIA_INDEXING_KEY=$&#123;HEXO_ALGOLIA_INDEXING_KEY&#125;- hexo algoliaafter_script:- cd ./dist- git init- git config --global user.name 'sakitam-fdd'- git config --global user.email 'smilefdd@gmail.com'- git add .- git commit -m "update my website"- git push --force --quiet "https://$&#123;TRAVIS_GITHUB&#125;@github.com/sakitam-fdd/sakitam-fdd.github.io" master:master 测试结果 推送一篇新主题到 website 仓库，观察 travis-ci构建过程当出现 Done. Your build exited with 0.后表示构建并且更新blog成功，稍等一分钟可以刷新你的blog查看最新结果。]]></content>
      <categories>
        <category>前端</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>持续集成</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎样快速搭建一个博客]]></title>
    <url>%2F2017%2F04%2F08%2FblogStart%2F</url>
    <content type="text"><![CDATA[简介：hexo是一款基于Node.js的静态博客框架，他可以方便的生成静态网页，而且不需要你去关注页面布局这些问题，只需要专注于内容。 必要环境 首先要安装 Node.js， Node.js 自带了软件包管理器 npm，hexo 需要 Node.js v0.6 以上支持，建议使用最新版 Node.js。 装完node后可以测试一下是否安装成功,命令窗口执行下面命令能正确输出版本号则安装成功。 1node -v 配置完之后建议将包地址换为国内淘宝镜像源。 1234npm config set registry https://registry.npm.taobao.org// 配置后可通过下面方式来验证是否成功npm config get registry// 或npm info express 全局安装hexo脚手架工具和hexo 12npm i -g hexo-clinpm i -g hexo 常用命令 1、 help ： 查看帮助信息 2、 init [文件夹名] ： 创建一个hexo项目，不指定文件夹名，则在当前目录创建 3、 version ： 查看hexo的版本 4、 –config config-path ：指定配置文件，代替默认的_config.yml 5、 –cwd cwd-path ：自定义当前工作目录 5、 –debug ：调试模式，输出所有日志信息 6、 –safe ：安全模式，禁用所有的插件和脚本 7、 –silent ：无日志输出模式 8、 generate ：编译输出静态文件 9、 clean ：清空编译后的缓存和文件 10、server ：开启本地服务器 11、deploy ：部署 开始创建1hexo init myBlog 执行上述命令后会创建一个模板出来，剩下的就需要自己去改了 添加文章文章会自动生成在博客目录下source/_posts/start.md 1hexo new "start" #新建博文,其中start是博文题目 12345---title: 怎样快速搭建一个博客date: 2017-04-08 12:11:50tags: hexo--- 主题Hexo提供了官网的主题, 初始化hexo时也会自动生成一个主题, Hexo还支持个性定制主题, 可以根据自己的喜好对主题进行修改, 更多主题可以在官网中找到themes更改方法如下 12345678git clone https://github.com/iissnan/hexo-theme-next themes/next#在./_config.yml，修改主题为nexttheme: writing#查看本地效果hexo g #hexo generate简写hexo s #hexo server简写 更多设置请查看next主题官网 部署到github注意修改配置文件中的deploy配置。12345# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/sakitam-fdd/sakitam-fdd.github.io.git 然后执行12345678910111213141516171819hexo deploy #进行部署Initialized empty Git repository in E:\codeRepository\github\website/.deploy/.git/[master (root-commit) bb3079b] First commit 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 placeholder[info] Clearing .deploy folder...[info] Copying files from public folder...[master 6e24e8d] Site updated: 2017-04-08 11:16:23 172 files changed, 34969 insertions(+) create mode 100644 2017/04/08/Hello-World/index.html ... create mode 100644 "tags/\345\277\203\350\267\257\346\234\255\350\256\260/index.html"To git@github.com/sakitam-fdd/sakitam-fdd.github.io.git + 11237d0...6e24e8d master -&gt; master (forced update)Branch master set up to track remote branch master from git@github.com/sakitam-fdd/sakitam-fdd.github.io.git[info] Deploy done: github#表示部署成功]]></content>
      <categories>
        <category>前端</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
